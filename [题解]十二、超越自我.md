## 十二、超越自我

### 编程题



#### 求差集1

【问题描述】两个集合的差集定义如下：
集合A、B的差集，由所有属于A但不属于B的元素构成。
输入两个集合A、B，每个集合中元素都是自然数。求集合A、B的差集。
【输入形式】
从标准输入先输入集合元素个数，然后在下一行输入集合中的自然数元素，以空格分隔。
其中，每个集合都不输入重复的元素。
【输出形式】
输出差运算后集合中的元素，以空格分隔。输出元素的顺序与原有集合A输入的顺序一致。
如果A、B的差集为空集，则不输出任何数值。
【样例输入】

```
4
2 8 3 4
4
6 1 4 9
```

【样例输出】

```
2 8 3
```

【样例说明】从标准输入接收集合的元素个数和每个元素，输出集合A、B的差集。
【评分标准】该题要求输出差运算后集合中的元素，共有5个测试点。上传C语言文件名为sets.c。

```c
#include<stdio.h>
int getArray(int a[],int n);
int putArray(int a[],int n);
int main()
{
    int n=0;
    int m=0;
    scanf("%d",&n);
        int a[n];                   //定义集合A
    getArray(a,n);
    scanf("%d",&m);
        int b[m];                   //定义集合B
    getArray(b,m);
    int i=0,j=0;
    for (i = 0; i < n; i++)
    {
        for (j = 0; j < m; j++)
            if (a[i]==b[j])
                break;
        if (j==m)
            printf("%d ",a[i]);
    }
}
int getArray(int a[],int n)
{
	for(int i=0;i<n;i++) {
		scanf("%d",&a[i]);
	}
return 0;
}

```



#### 求孪生数

【问题描述】孪生数定义： 如果 A 的约数(因数，**包含1，但不包含A本身**)之和等于 B ， B 的约数(因数)之和等于 A ， A 和 B 称为孪生数(**A和B不相等**)。试找出正整数 M 和 N 之间的孪生数。
【输入形式】从控制台输入两个正整数M和N(1<=M<N<=20000)，中间用一个空格分隔。
【输出形式】
在标准输出上输出符合题目描述的M和N之间的全部孪生数对(**包括M和N**)。每行输出一对孪生数，用一个空格隔开，小的先输出；各行孪生数按照第一个数从小到大的顺序输出，**一对孪生数只输出一次**。 如果没有符合要求的孪生数对，则输出字符串“**NONE**”。
【输入样例1】

```
20 300
```

【输出样例1】

```
220 284
```

【输入样例2】

```
200 250
```

【输出样例2】

```
NONE
```

【样例说明】
样例1输入的区间为[20,300]，其间有一对孪生数对，即：$220(1+2+4+5+10+11+20+22+44+55+110=284)$和$284(1+2+4+71+142=220)$。样例2输入的区间是$[200,250]$，其间没有孪生数对，所以输出字符串：$NONE$。
【评分标准】
该题要求输出区间中的所有孪生数对，共有5个测试点，提交程序文件名为example1.c或example1.cpp。

```c
#include<stdio.h>
int main()
{
    int a,b,c[20000]={0},flag=0;
    scanf("%d%d",&a,&b);
    for(int i=a;i<=b;i++)
    {
        int sum=0;
        for(int j=1;j<i;j++)
            if(i%j==0)sum+=j;
        if(sum>a&&sum<b)
            c[i]=sum;
    }
    for(int m=a;m<=b;m++)
    {
        if(m==c[c[m]]&&c[m]!='\0'&&c[m]!=m)
        {
            printf("%d %d \n",m,c[m]);
            flag=1;
            c[c[m]]=0;
        }
    }
    if (flag==0)
        printf("NONE");
    return 0;
}
```

